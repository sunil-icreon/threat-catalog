import { ECOSYSTEM_LIST } from "@/utilities/constants";
import { parseFirestoreDocument, toFirestoreFields } from "@/utilities/util";
import { GoogleAuth } from "google-auth-library";
import semver from "semver";
import {
  IDBRowType,
  IEcoSystemType,
  ILabelValueType,
  IRecord,
  IStatCacheType,
  IVulnerabilityType,
  SeverityStats,
  VulnerabilityResponse
} from "../types/vulnerability";
import { fetchRSSFeeds, sleep } from "./scanner";

interface CachedToken {
  token: string;
  expiry: number; // Unix timestamp in ms
}

interface IMappedVulConfigType {
  ecoSystem: string;
  fetchedAt: string;
  duration: number;
}

export class VulnerabilityService {
  private static instance: VulnerabilityService;
  public cacheStore: any = null;
  public resultKey: number = 0;
  public cache: IVulnerabilityType[] = [];
  public shouldReturnFromCache: boolean = false;
  private cachedToken: CachedToken | null = null;
  public statCache: IStatCacheType = {
    ecosystem: {},
    lastRefresh: "",
    severity: {},
    duration: {}
  };
  private lastUpdate: Date = new Date();

  private constructor() {}

  public static getInstance(): VulnerabilityService {
    if (!VulnerabilityService.instance) {
      VulnerabilityService.instance = new VulnerabilityService();
    }
    return VulnerabilityService.instance;
  }

  initialized = false;

  getEcosystemStats(
    vulList: Array<IVulnerabilityType>
  ): Record<string, number> {
    const stats: Record<string, number> = {};
    vulList?.forEach((vul) => {
      stats[vul.ecosystem.toLocaleLowerCase()] =
        (stats[vul.ecosystem.toLocaleLowerCase()] || 0) + 1;
    });
    return stats;
  }

  getSeverityStats(vulList: Array<IVulnerabilityType>): SeverityStats {
    const stats: SeverityStats = {};

    vulList.forEach((adv) => {
      const severity = adv.severity.toUpperCase();
      const ecosystem = adv.ecosystem;

      if (!stats[severity]) {
        stats[severity] = { total: 0 };
      }

      // Increment totals
      stats[severity].total += 1;
      stats[severity][ecosystem] = (stats[severity][ecosystem] || 0) + 1;
    });

    return stats;
  }

  getMappedData(
    advisories: IVulnerabilityType[],
    config: IMappedVulConfigType
  ) {
    const { duration, ecoSystem, fetchedAt } = config;
    const vulMapped: Array<IVulnerabilityType> = advisories.map(
      (adv: IVulnerabilityType) => {
        return {
          id: adv.id,
          summary: adv.summary ?? "",
          affectedVersions: adv.affectedVersions,
          description: adv.description ?? "",
          ecosystem: (ecoSystem || "").toLocaleLowerCase() as IEcoSystemType,
          severity: adv.severity as "LOW" | "MEDIUM" | "HIGH" | "CRITICAL",
          packageName: adv.packageName,
          cveId: adv.cve_id ?? "",
          publishedDate: adv.publishedDate ?? "",
          lastModified: adv.modifiedDate ?? "",
          references: adv.references,
          score: adv.score ?? "",
          score_vector: adv.score_vector ?? "",
          status: "ACTIVE",
          source: adv.source,
          epss: adv.epss,
          version: adv.version,
          cvss_severities: adv.cvss_severities,
          cvss: adv.cvss,
          cwes: adv.cwes,
          source_code_location: adv.source_code_location,
          detailURL: adv.detailURL,
          weaknesses: adv.weaknesses,
          patchedVersion: adv.patchedVersion,
          aliases: adv.aliases
        };
      }
    );

    const merged = [...this.cache, ...vulMapped];
    this.cache = Array.from(
      new Map(merged.map((item) => [item.id, item])).values()
    );

    this.statCache.duration[(ecoSystem || "").toLocaleLowerCase()] = {
      fetchedAt,
      duration
    };

    return vulMapped;
  }

  updateVulnerabilityStats() {
    const ecosystemStats = this.getEcosystemStats(this.cache);
    const severityStats = this.getSeverityStats(this.cache);
    this.shouldReturnFromCache = true;
    this.statCache = {
      ...this.statCache,
      ecosystem: ecosystemStats,
      severity: severityStats,
      lastRefresh: new Date().toISOString()
    };
  }

  getResponseObject(
    vulnerabilities: IVulnerabilityType[],
    stats: IStatCacheType
  ) {
    return {
      vulnerabilities: vulnerabilities,
      stats: stats,
      total: vulnerabilities.length,
      resultKey: this.resultKey
    };
  }

  async updateVulnerabilities() {
    const vulnerabilityDetails: Array<IDBRowType> =
      await this.readVulnerabilitiesFromDB();

    this.resultKey++;
    this.cache = [];
    this.shouldReturnFromCache = false;
    this.statCache = {
      ecosystem: {},
      severity: {},
      lastRefresh: "",
      duration: {}
    };

    if (vulnerabilityDetails && Array.isArray(vulnerabilityDetails)) {
      vulnerabilityDetails.map((vul: IDBRowType) => {
        const { advisories, name, duration, fetchedAt } = vul;
        const ecoSystem: string = name.split("_").pop() ?? "";
        this.getMappedData(advisories, { duration, ecoSystem, fetchedAt });
      });

      this.updateVulnerabilityStats();
    }

    return this.getResponseObject(this.cache, this.statCache);
  }

  private async initOnce() {
    if (!this.initialized) {
      this.initialized = true;
      console.log("✅ Running only once when first server request hits");
      await this.updateVulnerabilities();
    }
  }

  private async getAccessToken() {
    const now = Date.now();

    // ✅ If token exists and hasn't expired yet
    if (this.cachedToken && this.cachedToken.expiry > now + 60_000) {
      // Add 1 min buffer to avoid edge cases
      return this.cachedToken.token;
    }

    try {
      const auth = new GoogleAuth({
        credentials: {
          client_email: process.env.NEXT_PUBLIC_FIREBASE_EMAIL,
          private_key: process.env.NEXT_PUBLIC_FIREBASE_KEY?.replace(
            /\\n/g,
            "\n"
          )
        },
        scopes: ["https://www.googleapis.com/auth/datastore"]
      });

      const client = await auth.getClient();
      const tokenResponse = await client.getAccessToken();

      if (tokenResponse.token) {
        this.cachedToken = {
          token: tokenResponse.token ?? "",
          expiry: Date.now() + 3600 * 1000
        };

        return tokenResponse.token;
      } else {
        console.log("Invalid token value received");
      }
    } catch (e) {
      console.log("failed token", e);
    }
  }

  private async readVulnerabilitiesFromDB() {
    const token = await this.getAccessToken();

    if (!token) {
      console.log("Failed getting token from DB Server");
      return [];
    }

    const url = `https://firestore.googleapis.com/v1/projects/nodejs-vulnerability-db/databases/(default)/documents/vul-feed`;

    const res = await fetch(url, {
      next: {
        tags: ["advisories"],
        revalidate: 1000 * 60 * 60 * 6
      },
      headers: {
        Authorization: `Bearer ${token}`
      }
    });

    const data = await res.json();

    const documents = data.documents;
    let vulList: Array<any> = [];

    if (documents && Array.isArray(documents) && documents.length > 0) {
      documents.map((doc: any) => {
        vulList.push({ ...parseFirestoreDocument(doc), name: doc.name });
      });
    }

    return vulList;
  }

  private async writeVulnerabilitiestoDB(key: string, data: any) {
    try {
      const token = await this.getAccessToken();

      if (!token) {
        console.log("Failed getting token from DB Server");
        return false;
      }

      const body = toFirestoreFields(data);
      const url = `https://firestore.googleapis.com/v1/projects/nodejs-vulnerability-db/databases/(default)/documents/vul-feed/${key}`;

      await fetch(url, {
        method: "PATCH",
        body: JSON.stringify(body),
        headers: {
          Authorization: `Bearer ${token}`
        }
      });

      return true;
    } catch (e) {
      console.log("Error writing to DB", e);
      return false;
    }
  }

  public async getVulnerabilities(): Promise<VulnerabilityResponse> {
    await this.initOnce();

    let filteredVulnerabilities = [...this.cache];

    return {
      vulnerabilities: filteredVulnerabilities,
      stats: this.statCache,
      total: filteredVulnerabilities.length
    };
  }

  public async refreshCache(): Promise<void> {
    // this.cache = [...this.cache, ...newVulnerabilities];
    this.lastUpdate = new Date();
  }

  private fetchFeedForEcoSystem = async (
    duration: any,
    ecosystem: any,
    apiKey: string
  ) => {
    let vulListData = await fetchRSSFeeds({
      duration,
      ecosystem,
      apiKey
    });

    const { advisories } = vulListData;

    if (advisories && advisories.length > 0) {
      ecosystem = ecosystem?.toLocaleLowerCase();

      const mappedList = this.getMappedData(advisories, {
        duration,
        ecoSystem: ecosystem,
        fetchedAt: new Date().toISOString()
      });

      const responseData = {
        fetchedAt: new Date().toISOString(),
        count: mappedList.length,
        advisories: mappedList,
        duration
      };

      await this.writeVulnerabilitiestoDB(
        `vulnerability_feed_${ecosystem.toLowerCase()}`,
        {
          ...responseData
        }
      );

      this.updateVulnerabilityStats();
      return responseData;
    }
  };

  public async getLatestVulnerabilities(
    duration: any,
    ecosystem: any,
    apiKey: string
  ): Promise<any> {
    this.cache = [];
    this.statCache = {
      ecosystem: {},
      lastRefresh: "",
      severity: {},
      duration: {}
    };

    // Fetch for all ecosystems
    if (ecosystem === "") {
      ECOSYSTEM_LIST.map(async (eco: ILabelValueType) => {
        await this.fetchFeedForEcoSystem(duration, eco.value, apiKey);
      });
    } else {
      await this.fetchFeedForEcoSystem(duration, ecosystem, apiKey);
    }

    this.shouldReturnFromCache = false;

    await sleep(1000);
    return await this.updateVulnerabilities();
  }

  public getCacheInfo(): { lastUpdate: Date; totalVulnerabilities: number } {
    return {
      lastUpdate: this.lastUpdate,
      totalVulnerabilities: this.cache.length
    };
  }

  public returnVulnerabilitiesForPackages(packages: Array<IRecord>) {
    const targetMap = new Map<string, any[]>();
    for (const t of this.cache) {
      if (!targetMap.has(t.packageName)) targetMap.set(t.packageName, []);
      targetMap.get(t.packageName)!.push(t);
    }

    const matchedTargets: any[] = [];

    for (const s of packages) {
      const targets = targetMap.get(s.name) ?? [];
      for (const t of targets) {
        if (semver.satisfies(s.version, t.version)) {
          matchedTargets.push(t);
        }
      }
    }

    return matchedTargets;
  }
}
