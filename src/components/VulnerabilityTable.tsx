"use client";
import { EPSSData, formatRelativeTime } from "@/utilities/util";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import React from "react";
import { Table } from "react-bootstrap";
import { useVirtualizer } from "@tanstack/react-virtual";

import { IVulnerabilityType } from "@/types/vulnerability";
import { ECOSYSTEM_COLOR, ECOSYSTEM_NAME } from "@/utilities/constants";
import { AdvisoryDetailLink } from "./shared/AdvisoryDetailLink";
import { PackageDetailLink } from "./shared/PackageDetailLink";
import {
  AffectedVersionTags,
  CountPill,
  RenderEPSS
} from "./shared/UtilityComponents";

interface VulnerabilityTableProps {
  vulnerabilities: IVulnerabilityType[];
  onVulnerabilityClick?: (vulnerability: IVulnerabilityType) => void;
}

const severityVariants = {
  CRITICAL: "danger",
  HIGH: "warning",
  MEDIUM: "info",
  LOW: "success"
} as const;

const statusVariants = {
  ACTIVE: "danger",
  RESOLVED: "success",
  MITIGATED: "primary"
} as const;

// Memoized row component to prevent unnecessary re-renders
interface VulnerabilityTableRowProps
  extends React.HTMLAttributes<HTMLTableRowElement> {
  vulnerability: IVulnerabilityType;
  index: number;
  onVulnerabilityClick?: (vulnerability: IVulnerabilityType) => void;
}

const VulnerabilityTableRow = React.memo(
  React.forwardRef<HTMLTableRowElement, VulnerabilityTableRowProps>(
    ({ vulnerability, index, onVulnerabilityClick, ...props }, ref) => {
    return (
      <tr {...props}>
        <td className='fixed-first-column'>
          <span className='small'> {index + 1}.</span>
        </td>
        <td className='fixed-second-column'>
          <div className='fw-semibold text-dark'>
            <div className='small'>
              <AdvisoryDetailLink
                vulnerability={vulnerability}
                onVulnerabilityClick={onVulnerabilityClick}
              />
            </div>
          </div>
        </td>

        <td>
          <div className='package-name-cell-content'>
            <PackageDetailLink
              ecoSystem={vulnerability.ecosystem}
              packageName={vulnerability.packageName}
            />
          </div>
        </td>
        <td>
          <CountPill
            count={
              ECOSYSTEM_NAME[vulnerability.ecosystem] ??
              vulnerability.ecosystem
            }
            variant={ECOSYSTEM_COLOR[vulnerability.ecosystem] ?? "grey"}
          />
        </td>

        <td>
          {vulnerability.id ? (
            <CountPill
              count={
                <span className='small'>
                  {vulnerability.detailURL ? (
                    <a
                      href={vulnerability.detailURL}
                      target='_blank'
                      className='alt-link text-decoration-none'
                    >
                      {vulnerability.id}
                    </a>
                  ) : (
                    vulnerability.id
                  )}
                </span>
              }
              label={
                <span className='small'>
                  {vulnerability.source ?? "ID"}
                </span>
              }
              variant='grey'
            />
          ) : (
            <></>
          )}
        </td>

        <td>
          {vulnerability.affectedVersions && (
            <AffectedVersionTags
              affectedVersions={vulnerability.affectedVersions}
            />
          )}
        </td>

        <td>
          {vulnerability.patchedVersion ? (
            <PackageDetailLink
              ecoSystem={vulnerability.ecosystem}
              packageName={vulnerability.packageName}
              label={vulnerability.patchedVersion}
              version={vulnerability.patchedVersion}
              className='text-green small text-decoration-none'
            />
          ) : (
            <span className='text-high small'>No Fix Available</span>
          )}
        </td>
        <td>
          <span
            className={`text-${vulnerability.severity.toLowerCase()} small`}
          >
            {vulnerability.severity}
          </span>
        </td>
        <td>
          {vulnerability?.epss?.percentage ? (
            <RenderEPSS
              epss={vulnerability?.epss as EPSSData}
              displayType='table'
            />
          ) : (
            <></>
          )}
        </td>
        <td className='text-center'>
          {vulnerability.score ? (
            <div
              className='flex align-items-center text-muted small'
              title='Score'
            >
              <i className='bi bi-shield-exclamation me-1'></i>
              <strong className='text-dark'>{vulnerability.score}</strong>
            </div>
          ) : (
            <></>
          )}
        </td>

        <td>
          <div className='small text-muted'>
            {formatRelativeTime(vulnerability.publishedDate)}
          </div>
        </td>
      </tr>
    );
    }
  )
);

VulnerabilityTableRow.displayName = "VulnerabilityTableRow";

export default function VulnerabilityTable({
  vulnerabilities,
  onVulnerabilityClick
}: VulnerabilityTableProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const topScrollbarRef = useRef<HTMLDivElement>(null);
  const tbodyRef = useRef<HTMLTableSectionElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [hasHorizontalScroll, setHasHorizontalScroll] = useState(false);
  const dragStartRef = useRef({ x: 0, scrollLeft: 0 });
  const dragTargetRef = useRef<HTMLElement | null>(null);

  // Memoize vulnerabilities to prevent unnecessary virtualizer recalculations
  const memoizedVulnerabilities = useMemo(
    () => vulnerabilities,
    [vulnerabilities]
  );

  // Memoize callback to prevent row re-renders
  const handleVulnerabilityClick = useCallback(
    (vulnerability: IVulnerabilityType) => {
      onVulnerabilityClick?.(vulnerability);
    },
    [onVulnerabilityClick]
  );

  // Virtual scrolling setup - use the table container but with natural page flow
  // We'll use Intersection Observer to determine when table is visible
  const virtualizer = useVirtualizer({
    count: memoizedVulnerabilities.length,
    getScrollElement: () => {
      if (typeof window === "undefined") return null;
      return document.documentElement as Element;
    },
    estimateSize: () => 50, // Estimated row height in pixels
    overscan: 10, // Render 10 extra rows outside viewport for smooth scrolling
    measureElement:
      typeof window !== "undefined" && navigator.userAgent.indexOf("Firefox") === -1
        ? (element: Element | null) => element?.getBoundingClientRect().height ?? 50
        : undefined
  });

  // Track rendered row indices to prevent them from being removed
  const renderedIndicesRef = useRef<Set<number>>(new Set());
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: Math.min(30, memoizedVulnerabilities.length) });

  useEffect(() => {
    // Reset rendered indices when vulnerabilities change
    renderedIndicesRef.current.clear();
  }, [memoizedVulnerabilities]);

  useEffect(() => {
    const calculateVisibleRange = () => {
      if (!scrollContainerRef.current || memoizedVulnerabilities.length === 0) return;

      const tableRect = scrollContainerRef.current.getBoundingClientRect();
      const viewportTop = window.scrollY;
      const viewportBottom = window.scrollY + window.innerHeight;
      
      // Check if table is in viewport
      const tableTop = tableRect.top + viewportTop;
      const tableBottom = tableTop + tableRect.height;
      
      // Calculate which rows should be visible
      const rowHeight = 50;
      let calculatedStart = 0;
      let calculatedEnd = memoizedVulnerabilities.length;
      
      if (tableBottom >= viewportTop && tableTop <= viewportBottom) {
        // Table is in viewport, calculate visible range
        const visibleTop = Math.max(0, viewportTop - tableTop);
        const visibleBottom = Math.min(tableRect.height, viewportBottom - tableTop);
        
        calculatedStart = Math.max(0, Math.floor(visibleTop / rowHeight) - 30); // Large buffer
        calculatedEnd = Math.min(memoizedVulnerabilities.length, Math.ceil(visibleBottom / rowHeight) + 30);
      }
      
      // Add newly calculated indices to rendered set
      for (let i = calculatedStart; i < calculatedEnd; i++) {
        renderedIndicesRef.current.add(i);
      }
      
      // Calculate min and max from all rendered indices
      const renderedIndices = Array.from(renderedIndicesRef.current).sort((a, b) => a - b);
      if (renderedIndices.length > 0) {
        const minIndex = renderedIndices[0];
        const maxIndex = renderedIndices[renderedIndices.length - 1];
        
        // Ensure we include all rendered indices plus buffer
        const newStart = Math.max(0, minIndex - 10);
        const newEnd = Math.min(memoizedVulnerabilities.length, maxIndex + 11);
        
        setVisibleRange({ start: newStart, end: newEnd });
      } else {
        // Fallback to calculated range if no indices rendered yet
        setVisibleRange({ start: calculatedStart, end: calculatedEnd });
      }
    };

    // Initialize with initial range
    if (memoizedVulnerabilities.length > 0) {
      const initialEnd = Math.min(30, memoizedVulnerabilities.length);
      for (let i = 0; i < initialEnd; i++) {
        renderedIndicesRef.current.add(i);
      }
      setVisibleRange({ start: 0, end: initialEnd });
    }

    calculateVisibleRange();
    const handleScroll = () => calculateVisibleRange();
    const handleResize = () => calculateVisibleRange();

    window.addEventListener("scroll", handleScroll, { passive: true });
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [memoizedVulnerabilities.length]);

  useEffect(() => {
    const scrollContainer = scrollContainerRef.current;
    const topScrollbar = topScrollbarRef.current;

    if (!scrollContainer || !topScrollbar) return;

    // Ensure columns with width styles also have min-width to prevent shrinking
    const table = scrollContainer.querySelector("table");
    if (table) {
      const headers = table.querySelectorAll("th");
      headers.forEach((header) => {
        const htmlHeader = header as HTMLElement;
        const width = htmlHeader.style.width || htmlHeader.getAttribute("data-width");
        if (width) {
          htmlHeader.style.width = width;
          htmlHeader.style.minWidth = width;
          htmlHeader.style.maxWidth = width;
          // Also set on corresponding tbody cells
          const columnIndex = Array.from(header.parentElement?.children || []).indexOf(header);
          const cells = table.querySelectorAll(`tbody td:nth-child(${columnIndex + 1})`);
          cells.forEach((cell) => {
            const htmlCell = cell as HTMLElement;
            htmlCell.style.width = width;
            htmlCell.style.minWidth = width;
            if (!htmlCell.classList.contains("fixed-first-column") && !htmlCell.classList.contains("fixed-second-column")) {
              htmlCell.style.maxWidth = width;
            }
          });
        }
      });
    }

    // Sync top scrollbar with main scroll container
    const handleScroll = () => {
      if (topScrollbar) {
        topScrollbar.scrollLeft = scrollContainer.scrollLeft;
      }
    };

    // Sync main scroll container with top scrollbar
    const handleTopScroll = () => {
      if (scrollContainer) {
        scrollContainer.scrollLeft = topScrollbar.scrollLeft;
      }
    };

    scrollContainer.addEventListener("scroll", handleScroll);
    topScrollbar.addEventListener("scroll", handleTopScroll);

    // Set initial scrollbar width and sync content width
    const updateScrollbarWidth = () => {
      if (scrollContainer && topScrollbar) {
        const hasScroll =
          scrollContainer.scrollWidth > scrollContainer.clientWidth;
        setHasHorizontalScroll(hasScroll);
        topScrollbar.style.display = hasScroll ? "block" : "none";

        // Sync the scrollbar content width with the scroll container
        const scrollbarContent = topScrollbar.querySelector(
          ".vulnerability-table-top-scrollbar-content"
        ) as HTMLElement;
        if (scrollbarContent) {
          scrollbarContent.style.width = `${scrollContainer.scrollWidth}px`;
        }
      }
    };

    updateScrollbarWidth();

    // Update on resize
    const resizeObserver = new ResizeObserver(updateScrollbarWidth);
    resizeObserver.observe(scrollContainer);

    return () => {
      scrollContainer.removeEventListener("scroll", handleScroll);
      topScrollbar.removeEventListener("scroll", handleTopScroll);
      resizeObserver.disconnect();
    };
  }, [memoizedVulnerabilities]);

  // Mouse drag to scroll functionality - only enable if horizontal scroll is available
  useEffect(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer || !hasHorizontalScroll) return;

    const handleMouseDown = (e: MouseEvent) => {
      // Don't start drag on fixed columns or clickable elements
      const target = e.target as HTMLElement;
      if (
        target.closest(".fixed-first-column") ||
        target.closest(".fixed-second-column") ||
        target.closest("a") ||
        target.closest("button") ||
        target.closest("input") ||
        target.closest("select")
      ) {
        return;
      }

      // Only start drag on left mouse button
      if (e.button !== 0) return;

      setIsDragging(true);
      dragStartRef.current = {
        x: e.pageX,
        scrollLeft: scrollContainer.scrollLeft
      };
      dragTargetRef.current = target;
      scrollContainer.style.cursor = "grabbing";
      scrollContainer.style.userSelect = "none";
      e.preventDefault();
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;

      const x = e.pageX;
      const walk = (x - dragStartRef.current.x) * 2; // Multiply by 2 for faster scrolling
      scrollContainer.scrollLeft = dragStartRef.current.scrollLeft - walk;

      // Also update top scrollbar
      const topScrollbar = topScrollbarRef.current;
      if (topScrollbar) {
        topScrollbar.scrollLeft = scrollContainer.scrollLeft;
      }
    };

    const handleMouseUp = () => {
      if (isDragging) {
        setIsDragging(false);
        if (scrollContainer) {
          scrollContainer.style.cursor = "";
          scrollContainer.style.userSelect = "";
        }
        dragTargetRef.current = null;
      }
    };

    const handleMouseLeave = () => {
      if (isDragging) {
        setIsDragging(false);
        if (scrollContainer) {
          scrollContainer.style.cursor = "";
          scrollContainer.style.userSelect = "";
        }
        dragTargetRef.current = null;
      }
    };

    scrollContainer.addEventListener("mousedown", handleMouseDown);
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    scrollContainer.addEventListener("mouseleave", handleMouseLeave);

    return () => {
      scrollContainer.removeEventListener("mousedown", handleMouseDown);
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      scrollContainer.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [isDragging, hasHorizontalScroll]);

  return (
    <div className='vulnerability-table-wrapper'>
      <div ref={topScrollbarRef} className='vulnerability-table-top-scrollbar'>
        <div className='vulnerability-table-top-scrollbar-content'></div>
      </div>
      <div
        ref={scrollContainerRef}
        className={`table-responsive border rounded vulnerability-table-container ${
          isDragging ? "dragging" : ""
        } ${hasHorizontalScroll ? "scrollable" : ""}`}
      >
        <Table striped hover className='mb-0 table-hover'>
          <colgroup>
            <col style={{ width: "50px" }} />
            <col style={{ width: "400px" }} />
            <col style={{ width: "300px" }} />
            <col style={{ width: "80px" }} />
            <col style={{ width: "100px" }} />
            <col style={{ width: "180px" }} />
            <col style={{ width: "180px" }} />
            <col style={{ width: "100px" }} />
            <col style={{ width: "80px" }} />
            <col style={{ width: "80px" }} />
            <col style={{ width: "120px" }} />
          </colgroup>
          <thead className='table-dark'>
            <tr>
              <th className='fixed-first-column'>#</th>
              <th className='fixed-second-column'>Title</th>
              <th>Package</th>
              <th>Source</th>
              <th>ID</th>
              <th>Affected Version</th>
              <th>Fixed Version</th>
              <th>Severity</th>
              <th>EPSS</th>
              <th>Score/10</th>
              <th>Published</th>
            </tr>
          </thead>
          <tbody ref={tbodyRef}>
            {/* Virtual spacer before visible rows */}
            {visibleRange.start > 0 && (
              <tr>
                <td
                  colSpan={11}
                  style={{
                    height: `${visibleRange.start * 50}px`,
                    padding: 0,
                    border: 0,
                    lineHeight: 0
                  }}
                />
              </tr>
            )}
            {/* Render only visible rows */}
            {Array.from({ length: visibleRange.end - visibleRange.start }, (_, i) => {
              const index = visibleRange.start + i;
              const vulnerability = memoizedVulnerabilities[index];
              if (!vulnerability) return null;
              return (
                <VulnerabilityTableRow
                  key={vulnerability.id}
                  vulnerability={vulnerability}
                  index={index}
                  onVulnerabilityClick={handleVulnerabilityClick}
                />
              );
            })}
            {/* Virtual spacer after visible rows */}
            {visibleRange.end < memoizedVulnerabilities.length && (
              <tr>
                <td
                  colSpan={11}
                  style={{
                    height: `${(memoizedVulnerabilities.length - visibleRange.end) * 50}px`,
                    padding: 0,
                    border: 0,
                    lineHeight: 0
                  }}
                />
              </tr>
            )}
          </tbody>
        </Table>
      </div>
    </div>
  );
}
