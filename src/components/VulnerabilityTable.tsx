"use client";
import { EPSSData, formatRelativeTime } from "@/utilities/util";
import { useVirtualizer } from "@tanstack/react-virtual";
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState
} from "react";
import { OverlayTrigger, Table, Tooltip } from "react-bootstrap";

import { IVulnerabilityType } from "@/types/vulnerability";
import { ECOSYSTEM_COLOR, ECOSYSTEM_NAME } from "@/utilities/constants";
import { AdvisoryDetailLink } from "./shared/AdvisoryDetailLink";
import { PackageDetailLink } from "./shared/PackageDetailLink";
import {
  AffectedVersionTags,
  CountPill,
  RenderEPSS
} from "./shared/UtilityComponents";

interface VulnerabilityTableProps {
  vulnerabilities: IVulnerabilityType[];
  onVulnerabilityClick?: (vulnerability: IVulnerabilityType) => void;
}

const severityVariants = {
  CRITICAL: "danger",
  HIGH: "warning",
  MEDIUM: "info",
  LOW: "success"
} as const;

// Function to get CVSS score description based on value
const getScoreDescription = (score: string | number | undefined): string => {
  if (!score) return "No score available";

  const scoreNum = typeof score === "string" ? parseFloat(score) : score;

  if (isNaN(scoreNum)) return "Invalid score";

  if (scoreNum === 0.0) {
    return "None - No impact";
  } else if (scoreNum >= 0.1 && scoreNum <= 3.9) {
    return "Low - Minimal impact, may require local access or user interaction";
  } else if (scoreNum >= 4.0 && scoreNum <= 6.9) {
    return "Medium - Moderate impact, may allow unauthorized access to some resources";
  } else if (scoreNum >= 7.0 && scoreNum <= 8.9) {
    return "High - Significant impact, may allow unauthorized access to sensitive data or system compromise";
  } else if (scoreNum >= 9.0 && scoreNum <= 10.0) {
    return "Critical - Severe impact, may allow complete system compromise or remote code execution";
  }

  return "CVSS Score";
};

const statusVariants = {
  ACTIVE: "danger",
  RESOLVED: "success",
  MITIGATED: "primary"
} as const;

// Memoized row component to prevent unnecessary re-renders
interface VulnerabilityTableRowProps
  extends React.HTMLAttributes<HTMLTableRowElement> {
  vulnerability: IVulnerabilityType;
  index: number;
  onVulnerabilityClick?: (vulnerability: IVulnerabilityType) => void;
}

const VulnerabilityTableRow = React.memo(
  React.forwardRef<HTMLTableRowElement, VulnerabilityTableRowProps>(
    ({ vulnerability, index, onVulnerabilityClick, ...props }, ref) => {
      return (
        <tr {...props}>
          <td className='fixed-first-column'>
            <span className='small'> {index + 1}.</span>
          </td>
          <td className='fixed-second-column'>
            <div className='fw-semibold text-dark'>
              <div className='small'>
                <AdvisoryDetailLink
                  vulnerability={vulnerability}
                  onVulnerabilityClick={onVulnerabilityClick}
                />
              </div>
            </div>
          </td>

          <td>
            <div className='package-name-cell-content'>
              <PackageDetailLink
                ecoSystem={vulnerability.ecosystem}
                packageName={vulnerability.packageName}
              />
            </div>
          </td>
          <td>
            <CountPill
              count={
                ECOSYSTEM_NAME[vulnerability.ecosystem] ??
                vulnerability.ecosystem
              }
              variant={ECOSYSTEM_COLOR[vulnerability.ecosystem] ?? "grey"}
            />
          </td>

          <td>
            {vulnerability.id ? (
              <CountPill
                count={
                  <span className='small'>
                    {vulnerability.detailURL ? (
                      <a
                        href={vulnerability.detailURL}
                        target='_blank'
                        className='alt-link text-decoration-none'
                      >
                        {vulnerability.id}
                      </a>
                    ) : (
                      vulnerability.id
                    )}
                  </span>
                }
                label={
                  <span className='small'>{vulnerability.source ?? "ID"}</span>
                }
                variant='grey'
              />
            ) : (
              <></>
            )}
          </td>

          <td>
            {vulnerability.affectedVersions && (
              <AffectedVersionTags
                affectedVersions={vulnerability.affectedVersions}
              />
            )}
          </td>

          <td>
            {vulnerability.patchedVersion ? (
              <PackageDetailLink
                ecoSystem={vulnerability.ecosystem}
                packageName={vulnerability.packageName}
                label={vulnerability.patchedVersion}
                version={vulnerability.patchedVersion}
                className='text-green small text-decoration-none'
              />
            ) : (
              <span className='text-high small'>No Fix Available</span>
            )}
          </td>
          <td>
            <span
              className={`text-${vulnerability.severity.toLowerCase()} small`}
            >
              {vulnerability.severity}
            </span>
          </td>
          <td>
            {vulnerability?.epss?.percentage ? (
              <RenderEPSS
                epss={vulnerability?.epss as EPSSData}
                displayType='table'
              />
            ) : (
              <></>
            )}
          </td>

          <td>
            {(() => {
              // Check both weaknesses and cwes fields
              const cweList =
                vulnerability.weaknesses || vulnerability.cwes || [];
              if (cweList.length > 0) {
                return (
                  <div className='d-flex flex-wrap gap-1'>
                    {cweList.slice(0, 2).map((cwe: any, idx: number) => {
                      // Extract CWE ID - handle different formats
                      let cweId = "";
                      let cweNumber = "";
                      let cweName = "";

                      if (typeof cwe === "string") {
                        cweId = cwe;
                      } else if (cwe.id) {
                        cweId = cwe.id;
                        cweName = cwe.name || "";
                      } else if (cwe.cweId) {
                        cweId = cwe.cweId;
                        cweName = cwe.name || "";
                      } else if (cwe.cwe_id) {
                        cweId = cwe.cwe_id;
                        cweName = cwe.name || "";
                      }

                      // Extract number from CWE-79 format
                      if (cweId) {
                        const match = cweId.match(/CWE-?(\d+)/i);
                        cweNumber = match
                          ? match[1]
                          : cweId.replace(/CWE-?/i, "");
                      }

                      // Build tooltip text with CWE name if available
                      const tooltipText =
                        cweName && cweId !== cweName ? (
                          <>
                            <div className='fw-semibold'>{cweId}</div>
                            <div className='small'>{cweName}</div>
                          </>
                        ) : (
                          cweId
                        );

                      return (
                        <span key={idx} className='small'>
                          <OverlayTrigger
                            placement='top'
                            overlay={
                              <Tooltip id={`cwe-tooltip-${idx}`}>
                                {tooltipText}
                              </Tooltip>
                            }
                          >
                            <a
                              href={`https://cwe.mitre.org/data/definitions/${cweNumber}.html`}
                              target='_blank'
                              rel='noopener noreferrer'
                              className='text-decoration-none'
                            >
                              {cweId}
                            </a>
                          </OverlayTrigger>
                        </span>
                      );
                    })}
                    {cweList.length > 2 && (
                      <OverlayTrigger
                        placement='top'
                        overlay={
                          <Tooltip id='cwe-more-tooltip'>
                            {`${cweList.length - 2} more CWE(s)`}
                          </Tooltip>
                        }
                      >
                        <span className='small text-muted'>
                          +{cweList.length - 2}
                        </span>
                      </OverlayTrigger>
                    )}
                  </div>
                );
              }
              return <span className='small text-muted'>-</span>;
            })()}
          </td>
          <td className='text-center'>
            {vulnerability.score ? (
              <OverlayTrigger
                placement='top'
                overlay={
                  <Tooltip id='score-tooltip'>
                    <div>
                      <strong>CVSS Score: {vulnerability.score}</strong>
                      <br />
                      {getScoreDescription(vulnerability.score)}
                    </div>
                  </Tooltip>
                }
              >
                <div className='flex align-items-center text-muted small'>
                  <i className='bi bi-shield-exclamation me-1'></i>
                  <strong className='text-dark'>{vulnerability.score}</strong>
                </div>
              </OverlayTrigger>
            ) : (
              <></>
            )}
          </td>

          <td>
            <div className='small text-muted'>
              {formatRelativeTime(vulnerability.publishedDate)}
            </div>
          </td>
        </tr>
      );
    }
  )
);

VulnerabilityTableRow.displayName = "VulnerabilityTableRow";

type SortColumn =
  | "title"
  | "package"
  | "source"
  | "severity"
  | "epss"
  | "score"
  | "published"
  | null;
type SortDirection = "asc" | "desc";

export default function VulnerabilityTable({
  vulnerabilities,
  onVulnerabilityClick
}: VulnerabilityTableProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const tbodyRef = useRef<HTMLTableSectionElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [hasHorizontalScroll, setHasHorizontalScroll] = useState(false);
  const [sortColumn, setSortColumn] = useState<SortColumn>(null);
  const [sortDirection, setSortDirection] = useState<SortDirection>("asc");
  const dragStartRef = useRef({ x: 0, scrollLeft: 0 });
  const dragTargetRef = useRef<HTMLElement | null>(null);

  // Sorting function
  const sortVulnerabilities = (
    vulns: IVulnerabilityType[],
    column: SortColumn,
    direction: SortDirection
  ): IVulnerabilityType[] => {
    if (!column) return vulns;

    const sorted = [...vulns].sort((a, b) => {
      let comparison = 0;

      switch (column) {
        case "title":
          const titleA = a.summary || a.id || "";
          const titleB = b.summary || b.id || "";
          comparison = titleA.localeCompare(titleB);
          break;

        case "package":
          const packageA = a.packageName || "";
          const packageB = b.packageName || "";
          comparison = packageA.localeCompare(packageB);
          break;

        case "source":
          const sourceA = ECOSYSTEM_NAME[a.ecosystem] || a.ecosystem || "";
          const sourceB = ECOSYSTEM_NAME[b.ecosystem] || b.ecosystem || "";
          comparison = sourceA.localeCompare(sourceB);
          break;

        case "severity":
          const severityOrder = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
          const severityA =
            severityOrder[a.severity as keyof typeof severityOrder] || 0;
          const severityB =
            severityOrder[b.severity as keyof typeof severityOrder] || 0;
          comparison = severityA - severityB;
          break;

        case "epss":
          const epssA = a.epss?.percentage
            ? parseFloat(String(a.epss.percentage))
            : -1;
          const epssB = b.epss?.percentage
            ? parseFloat(String(b.epss.percentage))
            : -1;
          // Sort items without EPSS to the end
          if (epssA === -1 && epssB === -1) return 0;
          if (epssA === -1) return 1;
          if (epssB === -1) return -1;
          comparison = epssA - epssB;
          break;

        case "score":
          const scoreA = a.score ? parseFloat(String(a.score)) : -1;
          const scoreB = b.score ? parseFloat(String(b.score)) : -1;
          // Sort items without score to the end
          if (scoreA === -1 && scoreB === -1) return 0;
          if (scoreA === -1) return 1;
          if (scoreB === -1) return -1;
          comparison = scoreA - scoreB;
          break;

        case "published":
          const dateA = new Date(a.publishedDate || 0).getTime();
          const dateB = new Date(b.publishedDate || 0).getTime();
          comparison = dateA - dateB;
          break;

        default:
          return 0;
      }

      return direction === "asc" ? comparison : -comparison;
    });

    return sorted;
  };

  // Handle column header click
  const handleSort = useCallback(
    (column: SortColumn, e?: React.MouseEvent) => {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }

      if (sortColumn === column) {
        // Toggle direction if clicking the same column
        setSortDirection((prev) => (prev === "asc" ? "desc" : "asc"));
      } else {
        // Set new column and default to ascending
        setSortColumn(column);
        setSortDirection("asc");
      }
    },
    [sortColumn]
  );

  // Memoize sorted vulnerabilities
  const memoizedVulnerabilities = useMemo(() => {
    const sorted = sortVulnerabilities(
      vulnerabilities,
      sortColumn,
      sortDirection
    );
    return sorted;
  }, [vulnerabilities, sortColumn, sortDirection]);

  // Memoize callback to prevent row re-renders
  const handleVulnerabilityClick = useCallback(
    (vulnerability: IVulnerabilityType) => {
      onVulnerabilityClick?.(vulnerability);
    },
    [onVulnerabilityClick]
  );

  // Virtual scrolling setup - use the table container but with natural page flow
  // We'll use Intersection Observer to determine when table is visible
  const virtualizer = useVirtualizer({
    count: memoizedVulnerabilities.length,
    getScrollElement: () => {
      if (typeof window === "undefined") return null;
      return document.documentElement as Element;
    },
    estimateSize: () => 50, // Estimated row height in pixels
    overscan: 10, // Render 10 extra rows outside viewport for smooth scrolling
    measureElement:
      typeof window !== "undefined" &&
      navigator.userAgent.indexOf("Firefox") === -1
        ? (element: Element | null) =>
            element?.getBoundingClientRect().height ?? 50
        : undefined
  });

  // Track rendered row indices to prevent them from being removed
  const renderedIndicesRef = useRef<Set<number>>(new Set());
  const [visibleRange, setVisibleRange] = useState({
    start: 0,
    end: Math.min(30, memoizedVulnerabilities.length)
  });

  useEffect(() => {
    // Reset rendered indices when vulnerabilities change or sorting changes
    renderedIndicesRef.current.clear();
    // Reset visible range to top when sorting changes
    if (memoizedVulnerabilities.length > 0) {
      const initialEnd = Math.min(30, memoizedVulnerabilities.length);
      setVisibleRange({ start: 0, end: initialEnd });
      for (let i = 0; i < initialEnd; i++) {
        renderedIndicesRef.current.add(i);
      }
    }
  }, [memoizedVulnerabilities.length, sortColumn, sortDirection]);

  useEffect(() => {
    const calculateVisibleRange = () => {
      if (!scrollContainerRef.current || memoizedVulnerabilities.length === 0)
        return;

      const tableRect = scrollContainerRef.current.getBoundingClientRect();
      const viewportTop = window.scrollY;
      const viewportBottom = window.scrollY + window.innerHeight;

      // Check if table is in viewport
      const tableTop = tableRect.top + viewportTop;
      const tableBottom = tableTop + tableRect.height;

      // Calculate which rows should be visible
      const rowHeight = 50;
      let calculatedStart = 0;
      let calculatedEnd = memoizedVulnerabilities.length;

      if (tableBottom >= viewportTop && tableTop <= viewportBottom) {
        // Table is in viewport, calculate visible range
        const visibleTop = Math.max(0, viewportTop - tableTop);
        const visibleBottom = Math.min(
          tableRect.height,
          viewportBottom - tableTop
        );

        calculatedStart = Math.max(0, Math.floor(visibleTop / rowHeight) - 30); // Large buffer
        calculatedEnd = Math.min(
          memoizedVulnerabilities.length,
          Math.ceil(visibleBottom / rowHeight) + 30
        );
      }

      // Add newly calculated indices to rendered set
      for (let i = calculatedStart; i < calculatedEnd; i++) {
        renderedIndicesRef.current.add(i);
      }

      // Calculate min and max from all rendered indices
      const renderedIndices = Array.from(renderedIndicesRef.current).sort(
        (a, b) => a - b
      );
      if (renderedIndices.length > 0) {
        const minIndex = renderedIndices[0];
        const maxIndex = renderedIndices[renderedIndices.length - 1];

        // Ensure we include all rendered indices plus buffer
        const newStart = Math.max(0, minIndex - 10);
        const newEnd = Math.min(memoizedVulnerabilities.length, maxIndex + 11);

        setVisibleRange({ start: newStart, end: newEnd });
      } else {
        // Fallback to calculated range if no indices rendered yet
        setVisibleRange({ start: calculatedStart, end: calculatedEnd });
      }
    };

    // Initialize with initial range
    if (memoizedVulnerabilities.length > 0) {
      const initialEnd = Math.min(30, memoizedVulnerabilities.length);
      for (let i = 0; i < initialEnd; i++) {
        renderedIndicesRef.current.add(i);
      }
      setVisibleRange({ start: 0, end: initialEnd });
    }

    calculateVisibleRange();
    const handleScroll = () => calculateVisibleRange();
    const handleResize = () => calculateVisibleRange();

    window.addEventListener("scroll", handleScroll, { passive: true });
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [memoizedVulnerabilities.length]);

  useEffect(() => {
    const scrollContainer = scrollContainerRef.current;

    if (!scrollContainer) return;

    // Ensure columns with width styles also have min-width to prevent shrinking
    const table = scrollContainer.querySelector("table");
    if (table) {
      const headers = table.querySelectorAll("th");
      headers.forEach((header) => {
        const htmlHeader = header as HTMLElement;
        const width =
          htmlHeader.style.width || htmlHeader.getAttribute("data-width");
        if (width) {
          htmlHeader.style.width = width;
          htmlHeader.style.minWidth = width;
          htmlHeader.style.maxWidth = width;
          // Also set on corresponding tbody cells
          const columnIndex = Array.from(
            header.parentElement?.children || []
          ).indexOf(header);
          const cells = table.querySelectorAll(
            `tbody td:nth-child(${columnIndex + 1})`
          );
          cells.forEach((cell) => {
            const htmlCell = cell as HTMLElement;
            htmlCell.style.width = width;
            htmlCell.style.minWidth = width;
            if (
              !htmlCell.classList.contains("fixed-first-column") &&
              !htmlCell.classList.contains("fixed-second-column")
            ) {
              htmlCell.style.maxWidth = width;
            }
          });
        }
      });
    }

    // Check if horizontal scroll is available
    const updateScrollbarWidth = () => {
      if (scrollContainer) {
        const hasScroll =
          scrollContainer.scrollWidth > scrollContainer.clientWidth;
        setHasHorizontalScroll(hasScroll);
      }
    };

    updateScrollbarWidth();

    // Update on resize
    const resizeObserver = new ResizeObserver(updateScrollbarWidth);
    resizeObserver.observe(scrollContainer);

    return () => {
      resizeObserver.disconnect();
    };
  }, [memoizedVulnerabilities]);

  // Mouse drag to scroll functionality - only enable if horizontal scroll is available
  useEffect(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer || !hasHorizontalScroll) return;

    const handleMouseDown = (e: MouseEvent) => {
      // Don't start drag on fixed columns, clickable elements, or sortable headers
      const target = e.target as HTMLElement;

      // Check if clicking on table header (including sortable headers)
      if (
        target.closest("thead") ||
        target.closest("th") ||
        target.tagName === "TH"
      ) {
        return;
      }

      if (
        target.closest(".fixed-first-column") ||
        target.closest(".fixed-second-column") ||
        target.closest("a") ||
        target.closest("button") ||
        target.closest("input") ||
        target.closest("select")
      ) {
        return;
      }

      // Only start drag on left mouse button
      if (e.button !== 0) return;

      setIsDragging(true);
      dragStartRef.current = {
        x: e.pageX,
        scrollLeft: scrollContainer.scrollLeft
      };
      dragTargetRef.current = target;
      scrollContainer.style.cursor = "grabbing";
      scrollContainer.style.userSelect = "none";
      e.preventDefault();
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;

      const x = e.pageX;
      const walk = (x - dragStartRef.current.x) * 2; // Multiply by 2 for faster scrolling
      scrollContainer.scrollLeft = dragStartRef.current.scrollLeft - walk;
    };

    const handleMouseUp = () => {
      if (isDragging) {
        setIsDragging(false);
        if (scrollContainer) {
          scrollContainer.style.cursor = "";
          scrollContainer.style.userSelect = "";
        }
        dragTargetRef.current = null;
      }
    };

    const handleMouseLeave = () => {
      if (isDragging) {
        setIsDragging(false);
        if (scrollContainer) {
          scrollContainer.style.cursor = "";
          scrollContainer.style.userSelect = "";
        }
        dragTargetRef.current = null;
      }
    };

    scrollContainer.addEventListener("mousedown", handleMouseDown);
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    scrollContainer.addEventListener("mouseleave", handleMouseLeave);

    return () => {
      scrollContainer.removeEventListener("mousedown", handleMouseDown);
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      scrollContainer.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [isDragging, hasHorizontalScroll]);

  return (
    <div className='vulnerability-table-wrapper'>
      <div
        ref={scrollContainerRef}
        className={`table-responsive border rounded vulnerability-table-container ${
          isDragging ? "dragging" : ""
        } ${hasHorizontalScroll ? "scrollable" : ""}`}
        style={{
          minHeight: memoizedVulnerabilities.length > 0 ? "400px" : "200px"
        }}
      >
        <Table
          striped
          hover
          className='mb-0 table-hover'
          role='table'
          aria-label='Vulnerability list'
          aria-rowcount={memoizedVulnerabilities.length}
        >
          <caption className='visually-hidden'>
            List of security vulnerabilities with details including package
            name, severity, CVSS score, EPSS score, affected versions, and
            published date
          </caption>
          <colgroup>
            <col style={{ width: "50px" }} />
            <col style={{ width: "400px" }} />
            <col style={{ width: "300px" }} />
            <col style={{ width: "80px" }} />
            <col style={{ width: "100px" }} />
            <col style={{ width: "180px" }} />
            <col style={{ width: "180px" }} />
            <col style={{ width: "100px" }} />
            <col style={{ width: "80px" }} />
            <col style={{ width: "120px" }} />
            <col style={{ width: "80px" }} />
            <col style={{ width: "120px" }} />
          </colgroup>
          <thead style={{ backgroundColor: "#6c757d", color: "#ffffff" }}>
            <tr role='row'>
              <th
                className='fixed-first-column'
                scope='col'
                role='columnheader'
              >
                #
              </th>
              <th
                className='fixed-second-column'
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("title", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>Title</span>
                  {sortColumn === "title" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
              <th
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("package", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>Package</span>
                  {sortColumn === "package" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
              <th
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("source", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>EcoSystem</span>
                  {sortColumn === "source" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
              <th scope='col' role='columnheader'>
                ID
              </th>
              <th scope='col' role='columnheader'>
                Affected Version
              </th>
              <th scope='col' role='columnheader'>
                Fixed Version
              </th>
              <th
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("severity", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>Severity</span>
                  {sortColumn === "severity" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
              <th
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("epss", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>EPSS</span>
                  {sortColumn === "epss" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
              <th scope='col' role='columnheader'>
                CWE
              </th>
              <th
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("score", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>Score/10</span>
                  {sortColumn === "score" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
              <th
                scope='col'
                role='columnheader'
                style={{ cursor: "pointer", userSelect: "none" }}
                onClick={(e) => handleSort("published", e)}
              >
                <div className='d-flex align-items-center justify-content-between'>
                  <span>Published</span>
                  {sortColumn === "published" && (
                    <i
                      className={`bi bi-arrow-${
                        sortDirection === "asc" ? "up" : "down"
                      }-short ms-1`}
                    ></i>
                  )}
                </div>
              </th>
            </tr>
          </thead>
          <tbody ref={tbodyRef}>
            {/* Virtual spacer before visible rows */}
            {visibleRange.start > 0 && (
              <tr>
                <td
                  colSpan={12}
                  style={{
                    height: `${visibleRange.start * 50}px`,
                    padding: 0,
                    border: 0,
                    lineHeight: 0
                  }}
                />
              </tr>
            )}
            {/* Render only visible rows */}
            {Array.from(
              { length: visibleRange.end - visibleRange.start },
              (_, i) => {
                const index = visibleRange.start + i;
                const vulnerability = memoizedVulnerabilities[index];
                if (!vulnerability) return null;
                return (
                  <VulnerabilityTableRow
                    key={vulnerability.id}
                    vulnerability={vulnerability}
                    index={index}
                    onVulnerabilityClick={handleVulnerabilityClick}
                  />
                );
              }
            )}
            {/* Virtual spacer after visible rows */}
            {visibleRange.end < memoizedVulnerabilities.length && (
              <tr>
                <td
                  colSpan={12}
                  style={{
                    height: `${
                      (memoizedVulnerabilities.length - visibleRange.end) * 50
                    }px`,
                    padding: 0,
                    border: 0,
                    lineHeight: 0
                  }}
                />
              </tr>
            )}
          </tbody>
        </Table>
      </div>
    </div>
  );
}
