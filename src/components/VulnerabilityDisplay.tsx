"use client";
import { Col, Row } from "react-bootstrap";

import { IVulnerabilityType } from "@/types/vulnerability";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useVirtualizer } from "@tanstack/react-virtual";
import { useWindowSize } from "@/hooks/useWindowSize";
import VulnerabilityCard from "./VulnerabilityCard";
import VulnerabilityTable from "./VulnerabilityTable";

interface VulnerabilityDisplayProps {
  vulnerabilities: IVulnerabilityType[];
  onVulnerabilityClick?: (vulnerability: IVulnerabilityType) => void;
}

export default function VulnerabilityDisplay({
  vulnerabilities,
  onVulnerabilityClick
}: VulnerabilityDisplayProps) {
  const { isMobile } = useWindowSize();
  const cardContainerRef = useRef<HTMLDivElement>(null);

  const sortedVul = useMemo(() => {
    const sorted = [...vulnerabilities];
    sorted.sort(
      (a, b) =>
        new Date(b.publishedDate).getTime() -
        new Date(a.publishedDate).getTime()
    );
    return sorted;
  }, [vulnerabilities]);

  // Memoize callback to prevent card re-renders
  const handleVulnerabilityClick = useCallback(
    (vulnerability: IVulnerabilityType) => {
      onVulnerabilityClick?.(vulnerability);
    },
    [onVulnerabilityClick]
  );

  // Virtualization for mobile card view
  const cardVirtualizer = useVirtualizer({
    count: sortedVul.length,
    getScrollElement: () => {
      if (typeof window === "undefined") return null;
      return document.documentElement as Element;
    },
    estimateSize: () => 350, // Estimated card height in pixels
    overscan: 5, // Render 5 extra cards outside viewport
    measureElement:
      typeof window !== "undefined" && navigator.userAgent.indexOf("Firefox") === -1
        ? (element: Element | null) => element?.getBoundingClientRect().height ?? 350
        : undefined
  });

  // Track rendered card indices to prevent them from being removed
  const renderedCardIndicesRef = useRef<Set<number>>(new Set());
  const [visibleCardRange, setVisibleCardRange] = useState({
    start: 0,
    end: Math.min(10, sortedVul.length)
  });

  useEffect(() => {
    // Reset rendered indices when vulnerabilities change
    renderedCardIndicesRef.current.clear();
  }, [sortedVul]);

  useEffect(() => {
    if (!isMobile) return; // Only calculate for mobile view

    const calculateVisibleCardRange = () => {
      if (!cardContainerRef.current || sortedVul.length === 0) return;

      const containerRect = cardContainerRef.current.getBoundingClientRect();
      const viewportTop = window.scrollY;
      const viewportBottom = window.scrollY + window.innerHeight;

      // Check if container is in viewport
      const containerTop = containerRect.top + viewportTop;
      const containerBottom = containerTop + containerRect.height;

      // Calculate which cards should be visible
      const cardHeight = 350;
      let calculatedStart = 0;
      let calculatedEnd = sortedVul.length;

      if (containerBottom >= viewportTop && containerTop <= viewportBottom) {
        // Container is in viewport, calculate visible range
        const visibleTop = Math.max(0, viewportTop - containerTop);
        const visibleBottom = Math.min(
          containerRect.height,
          viewportBottom - containerTop
        );

        calculatedStart = Math.max(0, Math.floor(visibleTop / cardHeight) - 5);
        calculatedEnd = Math.min(
          sortedVul.length,
          Math.ceil(visibleBottom / cardHeight) + 5
        );
      }

      // Add newly calculated indices to rendered set
      for (let i = calculatedStart; i < calculatedEnd; i++) {
        renderedCardIndicesRef.current.add(i);
      }

      // Calculate min and max from all rendered indices
      const renderedIndices = Array.from(renderedCardIndicesRef.current).sort(
        (a, b) => a - b
      );
      if (renderedIndices.length > 0) {
        const minIndex = renderedIndices[0];
        const maxIndex = renderedIndices[renderedIndices.length - 1];

        // Ensure we include all rendered indices plus buffer
        const newStart = Math.max(0, minIndex - 3);
        const newEnd = Math.min(sortedVul.length, maxIndex + 4);

        setVisibleCardRange({ start: newStart, end: newEnd });
      } else {
        // Fallback to calculated range if no indices rendered yet
        setVisibleCardRange({ start: calculatedStart, end: calculatedEnd });
      }
    };

    // Initialize with initial range
    if (sortedVul.length > 0) {
      const initialEnd = Math.min(10, sortedVul.length);
      for (let i = 0; i < initialEnd; i++) {
        renderedCardIndicesRef.current.add(i);
      }
      setVisibleCardRange({ start: 0, end: initialEnd });
    }

    calculateVisibleCardRange();
    const handleScroll = () => calculateVisibleCardRange();
    const handleResize = () => calculateVisibleCardRange();

    window.addEventListener("scroll", handleScroll, { passive: true });
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [sortedVul.length, isMobile]);

  return (
    <>
      {isMobile ? (
        /* Card view for mobile and tablet */
        <div className='mb-3'>
          <div ref={cardContainerRef}>
            <div style={{ position: "relative" }}>
              {/* Virtual spacer before visible cards */}
              {visibleCardRange.start > 0 && (
                <div
                  style={{
                    height: `${visibleCardRange.start * 350}px`,
                    width: "100%"
                  }}
                />
              )}
              {/* Render only visible cards */}
              <Row className='g-4'>
                {Array.from(
                  { length: visibleCardRange.end - visibleCardRange.start },
                  (_, i) => {
                    const index = visibleCardRange.start + i;
                    const vulnerability = sortedVul[index];
                    if (!vulnerability) return null;
                    return (
                      <Col key={vulnerability.id} xs={12} sm={6}>
                        <VulnerabilityCard
                          vulnerability={vulnerability}
                          index={index}
                          onVulnerabilityClick={handleVulnerabilityClick}
                        />
                      </Col>
                    );
                  }
                )}
              </Row>
              {/* Virtual spacer after visible cards */}
              {visibleCardRange.end < sortedVul.length && (
                <div
                  style={{
                    height: `${(sortedVul.length - visibleCardRange.end) * 350}px`,
                    width: "100%"
                  }}
                />
              )}
            </div>
          </div>
        </div>
      ) : (
        /* Table view for large screens */
        <div className='mb-3'>
          <VulnerabilityTable
            vulnerabilities={sortedVul}
            onVulnerabilityClick={onVulnerabilityClick}
          />
        </div>
      )}
    </>
  );
}
